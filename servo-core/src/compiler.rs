//! Workflow compiler
//!
//! The compiler validates workflows, resolves dependencies, and generates
//! execution plans.

use crate::{asset::Asset, workflow::Workflow};
use std::collections::{HashMap, HashSet};
use thiserror::Error;

/// Errors that can occur during workflow compilation
#[derive(Debug, Error)]
pub enum CompileError {
    #[error("Circular dependency detected in workflow")]
    CircularDependency,

    #[error("Missing asset: {0}")]
    MissingAsset(String),

    #[error("Invalid workflow: {0}")]
    InvalidWorkflow(String),
}

/// Compiles workflows into execution plans
pub struct WorkflowCompiler {
    assets: HashMap<String, Asset>,
}

impl WorkflowCompiler {
    /// Create a new workflow compiler
    pub fn new() -> Self {
        Self {
            assets: HashMap::new(),
        }
    }

    /// Register an asset with the compiler
    pub fn register_asset(&mut self, asset: Asset) {
        self.assets.insert(asset.name.clone(), asset);
    }

    /// Compile a workflow and validate it
    pub fn compile(&self, workflow: &Workflow) -> Result<ExecutionPlan, CompileError> {
        // Validate all assets exist
        for asset_id in &workflow.assets {
            let asset_exists = self.assets.values().any(|a| a.id == *asset_id);
            if !asset_exists {
                return Err(CompileError::MissingAsset(format!("{:?}", asset_id)));
            }
        }

        // TODO: Implement topological sort for execution order
        // TODO: Detect circular dependencies
        // TODO: Generate execution plan

        Ok(ExecutionPlan {
            workflow_id: workflow.id,
            execution_order: workflow.assets.clone(),
        })
    }

    /// Check for circular dependencies in the asset graph
    fn has_circular_dependencies(&self) -> bool {
        // TODO: Implement cycle detection using DFS
        false
    }
}

impl Default for WorkflowCompiler {
    fn default() -> Self {
        Self::new()
    }
}

/// An execution plan generated by the compiler
#[derive(Debug, Clone)]
pub struct ExecutionPlan {
    /// The workflow being executed
    pub workflow_id: crate::workflow::WorkflowId,

    /// Assets in topologically sorted execution order
    pub execution_order: Vec<crate::asset::AssetId>,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::asset::Asset;
    use crate::workflow::Workflow;

    #[test]
    fn test_compiler_creation() {
        let compiler = WorkflowCompiler::new();
        assert_eq!(compiler.assets.len(), 0);
    }

    #[test]
    fn test_register_asset() {
        let mut compiler = WorkflowCompiler::new();
        let asset = Asset::new("test_asset");

        compiler.register_asset(asset.clone());

        assert_eq!(compiler.assets.len(), 1);
        assert!(compiler.assets.contains_key("test_asset"));
    }
}
